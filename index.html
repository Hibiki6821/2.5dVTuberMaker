<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2.5D VTuber Maker - Ultimate Edition ✨</title>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel (JSX変換) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Tailwind CSS (デザイン) -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Google Fonts (可愛くする) -->
    <link href="https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@400;700&display=swap" rel="stylesheet">

    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #f3f4f6; 
            font-family: 'M PLUS Rounded 1c', sans-serif;
        }
        /* スクロールバーをおしゃれに */
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-thumb { background: #a5b4fc; border-radius: 3px; }
        ::-webkit-scrollbar-track { background: transparent; }
        
        .range-slider {
            -webkit-appearance: none;
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #e2e8f0;
            outline: none;
        }
        .range-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #6366f1;
            cursor: pointer;
            transition: background .15s ease-in-out;
        }
        .range-slider::-webkit-slider-thumb:hover {
            background: #4f46e5;
        }
    </style>
    <!-- Firebase SDK (compat版 - グローバル変数として使用) -->
    <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-storage-compat.js"></script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        // ==========================================
        // Firebase 初期化
        // ==========================================
        const firebaseConfig = {
            apiKey: "AIzaSyDDz9cs9Wgx8Npjrh7FwUB4kF1h8Zwsiik",
            authDomain: "fantia-csv.firebaseapp.com",
            projectId: "fantia-csv",
            storageBucket: "fantia-csv.firebasestorage.app",
            messagingSenderId: "457081920405",
            appId: "1:457081920405:web:c4398ead16dc824b39f49c",
            measurementId: "G-XPCRQ4KWCH"
        };
        const fbApp = firebase.initializeApp(firebaseConfig);
        const fbAuth = firebase.auth();
        const fbDb = firebase.firestore();
        const fbStorage = firebase.storage();

        // 匿名ログイン（自動・透過的）
        const fbAuthReady = fbAuth.signInAnonymously()
            .then(() => true)
            .catch(e => { console.error('匿名ログイン失敗:', e); return false; });

        const { useState, useEffect, useRef, useCallback } = React;

        // ==========================================
        // アイコン (SVG)
        // ==========================================
        const Icons = {
            Layers: ({ className }) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><polygon points="12 2 2 7 12 12 22 7 12 2" /><polyline points="2 17 12 22 22 17" /><polyline points="2 12 12 17 22 12" /></svg>,
            ImageIcon: ({ className }) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><rect width="18" height="18" x="3" y="3" rx="2" ry="2" /><circle cx="9" cy="9" r="2" /><path d="m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21" /></svg>,
            Upload: ({ className }) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" /><polyline points="17 8 12 3 7 8" /><line x1="12" x2="12" y1="3" y2="15" /></svg>,
            RefreshCw: ({ className }) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8" /><path d="M21 3v5h-5" /><path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16" /><path d="M8 16H3v5" /></svg>,
            Move: ({ className }) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><polyline points="5 9 2 12 5 15" /><polyline points="9 5 12 2 15 5" /><polyline points="15 19 12 22 9 19" /><polyline points="19 9 22 12 19 15" /><line x1="2" x2="22" y1="12" y2="12" /><line x1="12" x2="12" y1="2" y2="22" /></svg>,
            Maximize: ({ className }) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M8 3H5a2 2 0 0 0-2 2v3" /><path d="M21 8V5a2 2 0 0 0-2-2h-3" /><path d="M3 16v3a2 2 0 0 0 2 2h3" /><path d="M16 21h3a2 2 0 0 0 2-2v-3" /></svg>,
            RotateCw: ({ className }) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M21 12a9 9 0 1 1-9-9c2.52 0 4.93 1 6.74 2.74L21 8" /><path d="M21 3v5h-5" /></svg>,
            Smile: ({ className }) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><circle cx="12" cy="12" r="10" /><path d="M8 14s1.5 2 4 2 4-2 4-2" /><line x1="9" x2="9.01" y1="9" y2="9" /><line x1="15" x2="15.01" y1="9" y2="9" /></svg>,
            Download: ({ className }) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" /><polyline points="7 10 12 15 17 10" /><line x1="12" x2="12" y1="15" y2="3" /></svg>,
            AlertCircle: ({ className }) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><circle cx="12" cy="12" r="10" /><line x1="12" x2="12" y1="8" y2="12" /><line x1="12" x2="12.01" y1="16" y2="16" /></svg>,
            Scissors: ({ className }) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><circle cx="6" cy="6" r="3" /><circle cx="6" cy="18" r="3" /><line x1="20" x2="8.12" y1="4" y2="15.88" /><line x1="14.47" x2="20" y1="14.48" y2="20" /><line x1="8.12" x2="12" y1="8.12" y2="12" /></svg>,
            Target: ({ className }) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><circle cx="12" cy="12" r="10" /><circle cx="12" cy="12" r="6" /><circle cx="12" cy="12" r="2" /></svg>,
            Sliders: ({ className }) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><line x1="4" x2="20" y1="21" y2="21" /><line x1="4" x2="20" y1="14" y2="14" /><line x1="4" x2="20" y1="7" y2="7" /><circle cx="12" cy="14" r="2" /><circle cx="8" cy="7" r="2" /><circle cx="16" cy="21" r="2" /></svg>,
            Save: ({ className }) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></svg>,
            LogIn: ({ className }) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M15 3h4a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-4"/><polyline points="10 17 15 12 10 7"/><line x1="15" x2="3" y1="12" y2="12"/></svg>,
            LogOut: ({ className }) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"/><polyline points="16 17 21 12 16 7"/><line x1="21" x2="9" y1="12" y2="12"/></svg>,
            Trash2: ({ className }) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>,
            Star: ({ className }) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/></svg>,
            Database: ({ className }) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><ellipse cx="12" cy="5" rx="9" ry="3"/><path d="M21 12c0 1.66-4 3-9 3s-9-1.34-9-3"/><path d="M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5"/></svg>,
            FolderOpen: ({ className }) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="m6 14 1.45-2.9A2 2 0 0 1 9.24 10H20a2 2 0 0 1 1.94 2.5l-1.55 6a2 2 0 0 1-1.94 1.5H4a2 2 0 0 1-2-2V5c0-1.1.9-2 2-2h3.93a2 2 0 0 1 1.66.9l.82 1.2a2 2 0 0 0 1.66.9H18a2 2 0 0 1 2 2v2"/></svg>
        };

        // ==========================================
        // ログイン画面
        // ==========================================
        const SITE_PASSWORD = 'Bulma_Go';

        const LoginScreen = ({ onLogin }) => {
            const [pw, setPw] = useState('');
            const [error, setError] = useState('');

            useEffect(() => {
                if (localStorage.getItem('vtm_site_pw') === SITE_PASSWORD) onLogin();
            }, []);

            const handleSubmit = (e) => {
                e.preventDefault();
                if (pw === SITE_PASSWORD) {
                    localStorage.setItem('vtm_site_pw', pw);
                    onLogin();
                } else {
                    setError('パスワードが違います');
                }
            };

            return (
                <div className="flex h-screen items-center justify-center bg-gradient-to-br from-indigo-100 to-pink-100">
                    <form onSubmit={handleSubmit} className="bg-white rounded-2xl shadow-2xl p-8 w-80 space-y-5">
                        <div className="text-center">
                            <Icons.Layers className="w-10 h-10 text-indigo-500 mx-auto mb-2"/>
                            <h1 className="text-lg font-bold text-indigo-600">2.5D VTuber Maker</h1>
                            <p className="text-xs text-gray-400 mt-1">パスワードを入力してください</p>
                        </div>
                        <input type="password" value={pw} onChange={e => setPw(e.target.value)}
                            placeholder="パスワード" autoFocus
                            className="w-full px-4 py-3 border-2 border-gray-200 rounded-xl text-sm focus:outline-none focus:border-indigo-400 transition-colors"/>
                        {error && <p className="text-red-500 text-xs font-bold text-center">{error}</p>}
                        <button type="submit" disabled={!pw}
                            className="w-full py-3 bg-gradient-to-r from-indigo-500 to-purple-600 text-white rounded-xl font-bold text-sm shadow-md hover:shadow-lg transition-all disabled:opacity-50">
                            ログイン
                        </button>
                    </form>
                </div>
            );
        };

        // ==========================================
        // ルートアプリ
        // ==========================================
        const App = () => {
            const [authenticated, setAuthenticated] = useState(false);
            if (!authenticated) return <LoginScreen onLogin={() => setAuthenticated(true)} />;
            return <VtuberMaker />;
        };

        // ==========================================
        // Main Application
        // ==========================================
        const VtuberMaker = () => {
            const [libsLoaded, setLibsLoaded] = useState(false);
            const [bgImage, setBgImage] = useState(null);
            const [model, setModel] = useState(null);
            const [loading, setLoading] = useState(false);
            const [loadingText, setLoadingText] = useState('');
            const [expressions, setExpressions] = useState([]);
            const [errorMsg, setErrorMsg] = useState('');
            const [loadProgress, setLoadProgress] = useState(0);

            // Firebase保存用状態
            const [savedModels, setSavedModels] = useState([]);
            const [savedPresets, setSavedPresets] = useState([]);
            const [currentModelId, _setCurrentModelId] = useState(() => localStorage.getItem('vtm_currentModelId') || null);
            const setCurrentModelId = (id) => { _setCurrentModelId(id); if (id) localStorage.setItem('vtm_currentModelId', id); else localStorage.removeItem('vtm_currentModelId'); };
            const [currentZipFile, setCurrentZipFile] = useState(null);
            const [isDragging, setIsDragging] = useState(false);

            // バッチ画像モード
            const [batchMode, setBatchMode] = useState(false);
            const [batchImages, setBatchImages] = useState([]); // [{url, name, thumbnailUrl, transform, allParameters, parameters, canvasSize, faceDetected}]
            const [currentImageIdx, setCurrentImageIdx] = useState(-1);
            const [selectedImageIdxs, setSelectedImageIdxs] = useState(new Set());

            const [authReady, setAuthReady] = useState(false);

            // 起動時に匿名ログイン完了を待ってからモデル一覧読み込み
            useEffect(() => {
                fbAuthReady.then(ok => {
                    if (ok) {
                        setAuthReady(true);
                        loadSavedModels();
                    } else {
                        setErrorMsg('Firebase認証に失敗しました。Firebase Consoleで「Authentication → Sign-in method → 匿名」を有効にしてください。');
                    }
                });
            }, []);

            // モデル一覧読み込み（＋自動選択でプリセット復元）
            const loadSavedModels = async () => {
                try {
                    const snap = await fbDb.collection('models').orderBy('createdAt', 'desc').get();
                    const models = snap.docs.map(d => ({ id: d.id, ...d.data() }));
                    setSavedModels(models);
                    // currentModelId がまだ無い or 該当モデルが存在しない → 最新モデルを自動選択
                    const savedId = localStorage.getItem('vtm_currentModelId');
                    const validId = models.find(m => m.id === savedId) ? savedId : (models.length > 0 ? models[0].id : null);
                    if (validId) {
                        setCurrentModelId(validId);
                        await loadPresetsForModel(validId);
                    }
                } catch (e) { console.error(e); }
            };

            // モデルをFirebaseに保存
            const saveModelToFirebase = async () => {
                if (!currentZipFile) { setErrorMsg('モデルを読み込んでください'); return; }
                if (!fbAuth.currentUser) {
                    try { await fbAuth.signInAnonymously(); } catch(e) {
                        setErrorMsg('Firebase認証失敗。匿名認証を有効にしてください。');
                        return;
                    }
                }
                const name = prompt('モデルの名前を入力してください:');
                if (!name) return;
                setLoading(true); setLoadingText('モデルを保存中...');
                try {
                    const modelId = `model_${Date.now()}`;
                    const storageRef = fbStorage.ref(`models/${modelId}.zip`);
                    await storageRef.put(currentZipFile);
                    await fbDb.collection('models').doc(modelId).set({
                        name, createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                        size: currentZipFile.size,
                        maskSettings: isMasked ? { enabled: true, y: maskSettings.y, radius: maskSettings.radius } : { enabled: false },
                    });
                    await loadSavedModels();
                    setCurrentModelId(modelId);
                    alert('モデルを保存しました！');
                } catch (e) { console.error(e); setErrorMsg('保存失敗: ' + e.message); }
                setLoading(false);
            };

            // 保存済みモデルを読み込み
            const loadModelFromFirebase = async (modelId) => {
                setLoading(true); setLoadingText('モデルをダウンロード中...');
                try {
                    // モデルのメタデータからマスク設定を復元
                    const modelDoc = await fbDb.collection('models').doc(modelId).get();
                    const modelData = modelDoc.data();
                    if (modelData?.maskSettings) {
                        const ms = modelData.maskSettings;
                        if (ms.enabled) {
                            setIsMasked(true);
                            setMaskSettings({ y: ms.y, radius: ms.radius });
                        } else {
                            setIsMasked(false);
                        }
                    } else {
                        setIsMasked(false);
                    }

                    const storageRef = fbStorage.ref(`models/${modelId}.zip`);
                    const url = await storageRef.getDownloadURL();
                    const res = await fetch(url);
                    const blob = await res.blob();
                    const file = new File([blob], 'model.zip', { type: 'application/zip' });
                    setCurrentZipFile(file);
                    setCurrentModelId(modelId);
                    await processZipFile(file);
                    await loadPresetsForModel(modelId);
                } catch (e) { console.error(e); setErrorMsg('読み込み失敗: ' + e.message); setLoading(false); }
            };

            // モデル削除
            const deleteModelFromFirebase = async (modelId) => {
                if (!confirm('このモデルを削除しますか？')) return;
                try {
                    await fbStorage.ref(`models/${modelId}.zip`).delete();
                    const presetsSnap = await fbDb.collection('models').doc(modelId).collection('presets').get();
                    const batch = fbDb.batch();
                    presetsSnap.docs.forEach(d => batch.delete(d.ref));
                    batch.delete(fbDb.collection('models').doc(modelId));
                    await batch.commit();
                    await loadSavedModels();
                    if (currentModelId === modelId) { setCurrentModelId(null); setSavedPresets([]); }
                    alert('削除しました');
                } catch (e) { console.error(e); setErrorMsg('削除失敗: ' + e.message); }
            };

            // プリセット一覧読み込み
            const loadPresetsForModel = async (modelId) => {
                try {
                    const snap = await fbDb.collection('models').doc(modelId).collection('presets').orderBy('createdAt', 'desc').get();
                    setSavedPresets(snap.docs.map(d => ({ id: d.id, ...d.data() })));
                } catch (e) { console.error(e); setSavedPresets([]); }
            };

            // プリセット保存
            const savePreset = async () => {
                if (!currentModelId || parameters.length === 0) {
                    setErrorMsg('モデルを保存してからプリセットを保存できます');
                    return;
                }
                const name = prompt('表情プリセットの名前を入力してください:');
                if (!name) return;
                try {
                    const paramData = parameters.map(p => ({ id: p.id, value: p.value }));
                    await fbDb.collection('models').doc(currentModelId).collection('presets').add({
                        name, params: paramData, createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                    });
                    await loadPresetsForModel(currentModelId);
                    alert('プリセット保存しました！');
                } catch (e) { console.error(e); setErrorMsg('プリセット保存失敗: ' + e.message); }
            };

            // プリセット適用
            const applyPreset = (preset) => {
                const paramMap = {};
                preset.params.forEach(p => { paramMap[p.id] = p.value; });
                const applyToParams = (params) => params.map(p => paramMap[p.id] !== undefined ? { ...p, value: paramMap[p.id] } : p);
                setParameters(prev => applyToParams(prev));
                setAllParameters(prev => applyToParams(prev));

                // バッチ: 選択中の画像にも一括適用
                if (batchMode && selectedImageIdxs.size > 0) {
                    setBatchImages(prev => prev.map((img, i) => {
                        if (!selectedImageIdxs.has(i) && i !== currentImageIdx) return img;
                        return { ...img, parameters: applyToParams(img.parameters), allParameters: applyToParams(img.allParameters) };
                    }));
                }
            };

            // プリセット削除
            const deletePreset = async (presetId) => {
                if (!currentModelId || !confirm('このプリセットを削除しますか？')) return;
                try {
                    await fbDb.collection('models').doc(currentModelId).collection('presets').doc(presetId).delete();
                    await loadPresetsForModel(currentModelId);
                } catch (e) { console.error(e); }
            };

            // Canvas & Pixi
            const canvasRef = useRef(null);
            const pixiAppRef = useRef(null);
            const modelRef = useRef(null);
            const modelContainerRef = useRef(null);
            const bgSpriteRef = useRef(null);
            const maskSpriteRef = useRef(null);
            const debugRingRef = useRef(null);
            const shuchuSpriteRef = useRef(null);

            // 集中線
            const [shuchuEnabled, setShuchuEnabled] = useState(false);
            const [shuchuSettings, setShuchuSettings] = useState({ x: 400, y: 300, scaleX: 1.0, scaleY: 1.0, opacity: 1.0 });


            // Transform
            const [transform, setTransform] = useState({ x: 400, y: 300, scale: 0.1, rotation: 0 });

            // Mask
            const [isMasked, setIsMasked] = useState(false);
            const [maskSettings, setMaskSettings] = useState({ radius: 300, y: 0 });

            // Parameters (Dynamic)
            // allParameters: 全パラメータ（Tickerで強制適用、呼吸等も固定）
            // parameters: UIに表示する顔系パラメータのみ
            const [allParameters, setAllParameters] = useState([]);
            const [parameters, setParameters] = useState([]);

            // 顔関連パラメータのカテゴリ定義
            const FACE_CATEGORIES = [
                { key: 'angle', label: '頭の向き', patterns: ['Angle'] },
                { key: 'eye', label: '目', patterns: ['Eye', 'Brow'] },
                { key: 'mouth', label: '口', patterns: ['Mouth', 'Lip'] },
                { key: 'other_face', label: 'その他(顔)', patterns: ['Cheek', 'Nose', 'Face', 'Smile'] },
            ];
            const getFaceCategory = (id) => {
                const lower = id.toLowerCase();
                for (const cat of FACE_CATEGORIES) {
                    if (cat.patterns.some(p => lower.includes(p.toLowerCase()))) return cat.key;
                }
                return null;
            };
            const isFaceParam = (id) => getFaceCategory(id) !== null;

            // カテゴリ折りたたみ状態
            const [openCategories, setOpenCategories] = useState({ angle: true, eye: true, mouth: false, other_face: false });
            const toggleCategory = (key) => setOpenCategories(prev => ({ ...prev, [key]: !prev[key] }));

            // Ref for Ticker (全パラメータを強制適用して呼吸等を止める)
            const allParametersRef = useRef([]);
            useEffect(() => { allParametersRef.current = allParameters; }, [allParameters]);

            // モデル読み込み後、バッチ画像のパラメータが空なら現在のモデルのデフォルト値で埋める
            useEffect(() => {
                if (!batchMode || batchImages.length === 0 || allParameters.length === 0) return;
                const needsUpdate = batchImages.some(img => img.allParameters.length === 0);
                if (!needsUpdate) return;
                const defaultAll = allParameters.map(p => ({ ...p, value: p.default }));
                const defaultFace = defaultAll.filter(p => isFaceParam(p.id));
                setBatchImages(prev => prev.map(img =>
                    img.allParameters.length === 0 ? { ...img, allParameters: defaultAll, parameters: defaultFace } : img
                ));
            }, [allParameters, batchMode, batchImages.length]);

            // -------------------------------------------------------------------------
            // ライブラリの読み込み
            // -------------------------------------------------------------------------
            useEffect(() => {
                const loadScript = (src) => {
                    return new Promise((resolve, reject) => {
                        if (document.querySelector(`script[src="${src}"]`)) { resolve(); return; }
                        const script = document.createElement('script');
                        script.src = src;
                        script.async = true;
                        script.crossOrigin = "anonymous";
                        script.onload = resolve;
                        script.onerror = () => {
                            document.head.removeChild(script);
                            reject(new Error(`Failed to load script: ${src}`));
                        };
                        document.head.appendChild(script);
                    });
                };

                const initScripts = async () => {
                    try {
                        setLoadingText('ライブラリを準備中...');
                        await loadScript('https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js');
                        setLoadProgress(25);
                        await loadScript('https://cdnjs.cloudflare.com/ajax/libs/pixi.js/6.5.9/browser/pixi.min.js');
                        setLoadProgress(50);
                        // Cubism 5 Core
                        await loadScript('https://cubism.live2d.com/sdk-web/cubismcore/live2dcubismcore.min.js');
                        setLoadProgress(75);
                        // Pixi Live2D Display (Cubism 4 support)
                        if (!window.PIXI?.live2d) {
                            await loadScript('https://cdn.jsdelivr.net/npm/pixi-live2d-display@0.4.0/dist/cubism4.min.js');
                        }
                        setLoadProgress(90);
                        // Face Mesh
                        if (!window.FaceMesh) await loadScript('https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js');
                        setLoadProgress(100);

                        setLibsLoaded(true);
                    } catch (e) {
                        console.error(e);
                        setErrorMsg('ライブラリの読み込みに失敗しました。リロードしてください。');
                    }
                };
                initScripts();
            }, []);

            // -------------------------------------------------------------------------
            // PixiJS 初期化
            // -------------------------------------------------------------------------
            useEffect(() => {
                if (!libsLoaded) return;
                if (!window.PIXI || !window.PIXI.live2d) return;

                try {
                    window.PIXI.utils.skipHello();
                    window.PIXI.live2d.Live2DModel.registerTicker(window.PIXI.Ticker);

                    const app = new window.PIXI.Application({
                        width: 800, height: 600,
                        backgroundColor: 0xeeeeee,
                        antialias: true,
                        preserveDrawingBuffer: true,
                        resolution: window.devicePixelRatio || 1,
                        autoDensity: true,
                    });

                    if (canvasRef.current) {
                        canvasRef.current.innerHTML = '';
                        canvasRef.current.appendChild(app.view);
                    }
                    pixiAppRef.current = app;
                    app.stage.sortableChildren = true;

                    // パラメータ適用は internalModel.update の上書きで処理するため
                    // Ticker での強制適用は不要

                    return () => {
                        try { app.destroy(true, { children: true, texture: true, baseTexture: true }); } catch (e) {}
                    };
                } catch (e) {
                    console.error(e);
                    setErrorMsg("描画エンジンの初期化に失敗しました。");
                }
            }, [libsLoaded]);

            // Transform同期
            useEffect(() => {
                if (modelContainerRef.current) {
                    const c = modelContainerRef.current;
                    c.position.set(transform.x, transform.y);
                    c.scale.set(transform.scale);
                    c.rotation = transform.rotation * (Math.PI / 180);
                }
            }, [transform]);

            // マスク処理 (Sprite Mask)
            useEffect(() => {
                if (!modelContainerRef.current || !pixiAppRef.current) return;
                const container = modelContainerRef.current;
                const app = pixiAppRef.current;

                // Cleanup
                if (maskSpriteRef.current) {
                    container.mask = null;
                    if(maskSpriteRef.current.parent === container) container.removeChild(maskSpriteRef.current);
                    maskSpriteRef.current.destroy({ texture: true, baseTexture: true });
                    maskSpriteRef.current = null;
                }
                if (debugRingRef.current) {
                    if(debugRingRef.current.parent === container) container.removeChild(debugRingRef.current);
                    debugRingRef.current.destroy();
                    debugRingRef.current = null;
                }

                if (isMasked) {
                    const graphics = new window.PIXI.Graphics();
                    graphics.beginFill(0xFFFFFF);
                    graphics.drawCircle(0, maskSettings.y, maskSettings.radius);
                    graphics.endFill();

                    const texture = app.renderer.generateTexture(graphics, { resolution: 2, scaleMode: window.PIXI.SCALE_MODES.LINEAR });
                    const maskSprite = new window.PIXI.Sprite(texture);
                    maskSprite.anchor.set(0.5, 0.5);
                    maskSprite.position.set(0, maskSettings.y);

                    container.addChild(maskSprite);
                    container.mask = maskSprite;
                    maskSpriteRef.current = maskSprite;

                    const ring = new window.PIXI.Graphics();
                    ring.lineStyle(4, 0xFF0000, 0.3);
                    ring.drawCircle(0, maskSettings.y, maskSettings.radius);
                    container.addChild(ring);
                    debugRingRef.current = ring;
                    graphics.destroy();
                }
            }, [isMasked, maskSettings, model]);

            // マスク設定変更時にFirestoreへ自動保存
            const maskSaveTimer = useRef(null);
            useEffect(() => {
                if (!currentModelId || !model) return;
                // デバウンス: スライダー操作中に連続保存しないよう500ms遅延
                clearTimeout(maskSaveTimer.current);
                maskSaveTimer.current = setTimeout(() => {
                    const data = isMasked
                        ? { maskSettings: { enabled: true, y: maskSettings.y, radius: maskSettings.radius } }
                        : { maskSettings: { enabled: false } };
                    fbDb.collection('models').doc(currentModelId).update(data).catch(e => console.error('マスク設定保存失敗:', e));
                }, 500);
                return () => clearTimeout(maskSaveTimer.current);
            }, [isMasked, maskSettings, currentModelId, model]);

            // 集中線画像
            const SHUCHU_DATA_URL = './shuchu.png';

            // 集中線スプライト管理
            useEffect(() => {
                const app = pixiAppRef.current;
                if (!app) return;

                if (shuchuEnabled) {
                    if (!shuchuSpriteRef.current) {
                        const sprite = window.PIXI.Sprite.from(SHUCHU_DATA_URL);
                        sprite.anchor.set(0.5, 0.5);
                        sprite.blendMode = window.PIXI.BLEND_MODES.SCREEN;
                        sprite.interactive = true;
                        sprite.buttonMode = true;
                        sprite.zIndex = 9999;

                        // Photoshop風ドラッグ
                        let dragging = false, dragOffset = { x: 0, y: 0 };
                        sprite.on('pointerdown', (e) => {
                            dragging = true;
                            const pos = e.data.getLocalPosition(sprite.parent);
                            dragOffset.x = pos.x - sprite.x;
                            dragOffset.y = pos.y - sprite.y;
                            e.stopPropagation();
                        });
                        const onMove = (e) => {
                            if (!dragging) return;
                            const pos = e.data.getLocalPosition(sprite.parent);
                            sprite.x = pos.x - dragOffset.x;
                            sprite.y = pos.y - dragOffset.y;
                            setShuchuSettings(prev => ({ ...prev, x: sprite.x, y: sprite.y }));
                        };
                        const onUp = () => { dragging = false; };
                        app.stage.on('pointermove', onMove);
                        app.stage.on('pointerup', onUp);
                        app.stage.on('pointerupoutside', onUp);
                        sprite._shuchuCleanup = () => {
                            app.stage.off('pointermove', onMove);
                            app.stage.off('pointerup', onUp);
                            app.stage.off('pointerupoutside', onUp);
                        };

                        app.stage.addChild(sprite);
                        shuchuSpriteRef.current = sprite;
                    }
                    // 設定を反映
                    const s = shuchuSpriteRef.current;
                    s.position.set(shuchuSettings.x, shuchuSettings.y);
                    s.scale.set(shuchuSettings.scaleX, shuchuSettings.scaleY);
                    s.alpha = shuchuSettings.opacity;
                    s.visible = true;
                } else {
                    if (shuchuSpriteRef.current) {
                        shuchuSpriteRef.current.visible = false;
                    }
                }
            }, [shuchuEnabled, shuchuSettings]);

            // キャンバスリサイズ時に集中線の位置をリセット
            useEffect(() => {
                if (!pixiAppRef.current || !shuchuEnabled) return;
                const w = pixiAppRef.current.renderer.screen.width;
                const h = pixiAppRef.current.renderer.screen.height;
                setShuchuSettings(prev => ({ ...prev, x: w / 2, y: h / 2 }));
            }, [bgImage]);

            // -------------------------------------------------------------------------
            // ハンドラ関連
            // -------------------------------------------------------------------------

            // 画像アップロード
            const handleImageFile = (file) => {
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (ev) => {
                    const imgUrl = ev.target.result;
                    setBgImage(imgUrl);
                    if (!pixiAppRef.current) return;
                    
                    if (bgSpriteRef.current) {
                        pixiAppRef.current.stage.removeChild(bgSpriteRef.current);
                        bgSpriteRef.current.destroy({ texture: true, baseTexture: true });
                    }
                    
                    const bg = window.PIXI.Sprite.from(imgUrl);
                    const texture = bg.texture;

                    const setupBg = () => {
                         const app = pixiAppRef.current;
                         const maxWidth = 800, maxHeight = 600;
                         let w = bg.width, h = bg.height;
                         if (w > maxWidth || h > maxHeight) {
                             const r = Math.min(maxWidth/w, maxHeight/h);
                             w *= r; h *= r;
                             bg.width = w; bg.height = h;
                         }
                         app.renderer.resize(w, h);
                         setTransform(p => ({ ...p, x: w/2, y: h/2 }));
                    };

                    // 画像が既にロードされているかチェック
                    if (texture.baseTexture.valid) {
                        setupBg();
                    } else {
                        texture.baseTexture.on('loaded', setupBg);
                    }
                    
                    bg.zIndex = -1;
                    pixiAppRef.current.stage.addChildAt(bg, 0);
                    bgSpriteRef.current = bg;
                };
                reader.readAsDataURL(file);
            };

            const handleImageUpload = (e) => handleImageFile(e.target.files[0]);

            // ユーティリティ
            const getImageDimensions = (url) => new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => resolve({ width: img.naturalWidth, height: img.naturalHeight });
                img.onerror = () => reject(new Error('画像読み込み失敗'));
                img.src = url;
            });
            const computeCanvasSize = (imgW, imgH) => {
                const maxW = 800, maxH = 600;
                let w = imgW, h = imgH;
                if (w > maxW || h > maxH) { const r = Math.min(maxW / w, maxH / h); w = Math.round(w * r); h = Math.round(h * r); }
                return { w, h };
            };
            const generateThumbnail = (url, maxDim) => new Promise((resolve) => {
                const img = new Image();
                img.onload = () => {
                    const c = document.createElement('canvas');
                    const r = Math.min(maxDim / img.naturalWidth, maxDim / img.naturalHeight);
                    c.width = Math.round(img.naturalWidth * r); c.height = Math.round(img.naturalHeight * r);
                    c.getContext('2d').drawImage(img, 0, 0, c.width, c.height);
                    resolve(c.toDataURL('image/jpeg', 0.7));
                };
                img.onerror = () => resolve(null);
                img.src = url;
            });

            // バッチ: 現在の画像の状態をbatchImagesに保存（container実値から取得）
            const saveCurrentImageState = () => {
                if (currentImageIdx < 0 || batchImages.length === 0) return;
                const c = modelContainerRef.current;
                const currentTransform = c ? { x: c.x, y: c.y, scale: c.scale.x, rotation: c.rotation * (180 / Math.PI) } : transform;
                const currentAllParams = allParametersRef.current.length > 0 ? allParametersRef.current : allParameters;
                const currentParams = currentAllParams.filter(p => isFaceParam(p.id));
                setBatchImages(prev => prev.map((img, i) =>
                    i === currentImageIdx ? { ...img, transform: currentTransform, allParameters: currentAllParams, parameters: currentParams, shuchuEnabled, shuchuSettings } : img
                ));
            };

            // バッチ: 画像切り替え
            const switchToImage = (idx, imageList) => {
                const imgs = imageList || batchImages;
                if (idx < 0 || idx >= imgs.length) return;
                const img = imgs[idx];
                setCurrentImageIdx(idx);

                const app = pixiAppRef.current;
                if (!app) return;

                // 背景差し替え
                if (bgSpriteRef.current) {
                    app.stage.removeChild(bgSpriteRef.current);
                    bgSpriteRef.current.destroy({ texture: true, baseTexture: true });
                    bgSpriteRef.current = null;
                }
                app.renderer.resize(img.canvasSize.w, img.canvasSize.h);
                const stage = app.stage;
                stage.hitArea = new window.PIXI.Rectangle(0, 0, img.canvasSize.w, img.canvasSize.h);

                const bg = window.PIXI.Sprite.from(img.url);
                bg.width = img.canvasSize.w; bg.height = img.canvasSize.h;
                bg.zIndex = -1;
                app.stage.addChildAt(bg, 0);
                bgSpriteRef.current = bg;

                // 状態復元
                setBgImage(img.url);
                setTransform(img.transform);
                // パラメータが空の場合は現在のモデルのパラメータを維持
                if (img.allParameters.length > 0) {
                    setAllParameters(img.allParameters);
                    setParameters(img.parameters);
                }
                // 集中線の状態を画像ごとに復元
                if (img.shuchuEnabled !== undefined) {
                    setShuchuEnabled(img.shuchuEnabled);
                    setShuchuSettings(img.shuchuSettings);
                }
            };

            // バッチ選択ヘルパー
            const toggleImageSelection = (idx) => {
                setSelectedImageIdxs(prev => { const n = new Set(prev); if (n.has(idx)) n.delete(idx); else n.add(idx); return n; });
            };
            const selectAllImages = () => setSelectedImageIdxs(new Set(batchImages.map((_, i) => i)));
            const deselectAllImages = () => setSelectedImageIdxs(new Set());

            // ZIPアップロード (Data URI + 自動解析)
            const handleZipFile = async (file) => {
                if (!file || !window.JSZip) return;
                const jsZip = new window.JSZip();
                const zip = await jsZip.loadAsync(file);
                const filePaths = Object.keys(zip.files);
                const hasModel = filePaths.some(p => p.toLowerCase().endsWith('.model3.json'));
                const imageExtensions = ['.png', '.jpg', '.jpeg', '.gif', '.webp', '.bmp'];
                const imageFiles = filePaths.filter(p => {
                    if (zip.files[p].dir) return false;
                    const lower = p.toLowerCase();
                    // __MACOSX や隠しファイルを除外
                    if (lower.includes('__macosx') || lower.includes('/.') || lower.startsWith('.')) return false;
                    return imageExtensions.some(ext => lower.endsWith(ext));
                });

                if (hasModel) {
                    // モデルZIP（既存処理）
                    setCurrentZipFile(file);
                    setCurrentModelId(null);
                    setSavedPresets([]);
                    await processZipFile(file);
                } else if (imageFiles.length > 0) {
                    // 画像バッチモード
                    await processImageZip(zip, imageFiles);
                } else {
                    setErrorMsg('ZIPにモデルも画像も見つかりません。');
                }
            };

            // 画像ZIPの処理
            const processImageZip = async (zip, imageFiles) => {
                setLoading(true);
                setBatchMode(true);
                imageFiles.sort();

                const newImages = [];
                for (let i = 0; i < imageFiles.length; i++) {
                    setLoadingText(`画像を読み込み中... (${i + 1}/${imageFiles.length})`);
                    const path = imageFiles[i];
                    try {
                        const ext = path.toLowerCase().split('.').pop();
                        const mime = ext === 'png' ? 'image/png' : ext === 'gif' ? 'image/gif' : ext === 'webp' ? 'image/webp' : 'image/jpeg';
                        const base64 = await zip.files[path].async('base64');
                        const url = `data:${mime};base64,${base64}`;
                        const dims = await getImageDimensions(url);
                        const cs = computeCanvasSize(dims.width, dims.height);
                        const thumbnailUrl = await generateThumbnail(url, 120);

                        // allParametersRef は常に最新値を持つ
                        const srcParams = allParametersRef.current.length > 0 ? allParametersRef.current : allParameters;
                        const defaultAllParams = srcParams.map(p => ({ ...p, value: p.default }));
                        const defaultParams = defaultAllParams.filter(p => isFaceParam(p.id));

                        newImages.push({
                            url, name: path.split('/').pop(), thumbnailUrl,
                            transform: { x: cs.w / 2, y: cs.h / 2, scale: 0.1, rotation: 0 },
                            allParameters: defaultAllParams, parameters: defaultParams,
                            canvasSize: cs, faceDetected: false,
                            shuchuEnabled: false, shuchuSettings: { x: cs.w / 2, y: cs.h / 2, scaleX: 1.0, scaleY: 1.0, opacity: 1.0 },
                        });
                    } catch (e) {
                        console.warn('画像スキップ:', path, e);
                    }
                }

                setBatchImages(newImages);
                setSelectedImageIdxs(new Set());
                if (newImages.length > 0) {
                    setCurrentImageIdx(0);
                    switchToImage(0, newImages);
                }
                setLoading(false);
            };

            const handleZipUpload = (e) => handleZipFile(e.target.files[0]);

            // ドラッグ&ドロップ
            const dragCounter = useRef(0);
            const handleDragEnter = (e) => { e.preventDefault(); e.stopPropagation(); dragCounter.current++; setIsDragging(true); };
            const handleDragLeave = (e) => { e.preventDefault(); e.stopPropagation(); dragCounter.current--; if (dragCounter.current <= 0) { dragCounter.current = 0; setIsDragging(false); } };
            const handleDragOver = (e) => { e.preventDefault(); e.stopPropagation(); };
            const handleDrop = (e) => {
                e.preventDefault(); e.stopPropagation();
                dragCounter.current = 0; setIsDragging(false);
                const file = e.dataTransfer.files[0];
                if (!file) return;
                const name = file.name.toLowerCase();
                if (name.endsWith('.zip')) {
                    handleZipFile(file);
                } else if (file.type.startsWith('image/')) {
                    handleImageFile(file);
                } else {
                    setErrorMsg('対応していないファイル形式です。画像またはZIPファイルをドロップしてください。');
                }
            };

            const processZipFile = async (file) => {
                if (!window.JSZip) return;
                setLoading(true);
                setLoadingText('ZIPを解析中...');
                setErrorMsg('');
                if (window.PIXI?.utils) window.PIXI.utils.clearTextureCache();

                try {
                    const jsZip = new window.JSZip();
                    const zip = await jsZip.loadAsync(file);

                    let modelConfigFile = Object.keys(zip.files).find(p => p.toLowerCase().endsWith('.model3.json'));
                    if (!modelConfigFile) throw new Error('.model3.json が見つかりません。');

                    // VTube Studio Config
                    let vtubeConfigFile = Object.keys(zip.files).find(p => p.toLowerCase().endsWith('.vtube.json'));
                    let vtubeSettings = null;
                    if (vtubeConfigFile) {
                        try {
                            const txt = await zip.files[vtubeConfigFile].async('string');
                            vtubeSettings = JSON.parse(txt);
                        } catch(e) { console.warn(e); }
                    }

                    setLoadingText('リソースを展開中...');
                    const fileMap = {};
                    const filePaths = Object.keys(zip.files);
                    
                    await Promise.all(filePaths.map(async (path) => {
                        if (!zip.files[path].dir) {
                            let mime = 'application/octet-stream';
                            const lp = path.toLowerCase();
                            if (lp.endsWith('.png')) mime = 'image/png';
                            else if (lp.endsWith('.jpg') || lp.endsWith('.jpeg')) mime = 'image/jpeg';
                            else if (lp.endsWith('.json')) mime = 'application/json';
                            else if (lp.endsWith('.moc3')) mime = 'application/octet-stream';

                            const base64 = await zip.files[path].async('base64');
                            const dataUrl = `data:${mime};base64,${base64}`;
                            const normalized = path.replace(/\\/g, '/');
                            fileMap[normalized] = dataUrl;
                            fileMap[normalized.toLowerCase()] = dataUrl;
                        }
                    }));

                    const modelJsonText = await zip.files[modelConfigFile].async('string');
                    let modelJsonObj = JSON.parse(modelJsonText);

                    // パス解決
                    const normalizedConfigPath = modelConfigFile.replace(/\\/g, '/');
                    const basePath = normalizedConfigPath.includes('/') 
                        ? normalizedConfigPath.substring(0, normalizedConfigPath.lastIndexOf('/') + 1) 
                        : '';
                    
                    const resolveUrl = (target) => {
                        let t = target.replace(/\\/g, '/').replace(/^\.\//, '');
                        const full = basePath + t;
                        if(fileMap[full]) return fileMap[full];
                        if(fileMap[full.toLowerCase()]) return fileMap[full.toLowerCase()];
                        if(fileMap[t]) return fileMap[t];
                        if(fileMap[t.toLowerCase()]) return fileMap[t.toLowerCase()];
                        // Fuzzy
                        const fname = t.split('/').pop().toLowerCase();
                        const match = Object.keys(fileMap).find(k => k.toLowerCase().endsWith('/' + fname) || k.toLowerCase() === fname);
                        if(match) return fileMap[match];
                        return null;
                    };

                    const replaceRecursive = (obj) => {
                        for (const k in obj) {
                            if (typeof obj[k] === 'string' && obj[k].length > 4) {
                                const url = resolveUrl(obj[k]);
                                if(url) obj[k] = url;
                            } else if (typeof obj[k] === 'object' && obj[k] !== null) {
                                replaceRecursive(obj[k]);
                            }
                        }
                    };
                    replaceRecursive(modelJsonObj);
                    modelJsonObj.url = `model_${Date.now()}.model3.json`;

                    setLoadingText('モデルを構築中...');
                    const { Live2DModel } = window.PIXI.live2d;

                    if (modelContainerRef.current) {
                        pixiAppRef.current.stage.removeChild(modelContainerRef.current);
                        modelContainerRef.current.destroy({ children: true });
                        modelContainerRef.current = null;
                        modelRef.current = null;
                    }

                    const model = await Live2DModel.from(modelJsonObj, { autoInteract: false });
                    model.anchor.set(0.5, 0.5);
                    model.autoplay = false; // Stop auto play

                    // ★ 自動アニメーション完全停止
                    // internalModel.update を丸ごと上書きして
                    // モーション・呼吸・物理・目パチを全てスキップする
                    const im = model.internalModel;
                    if (im) {
                        im.update = function(dt, now) {
                            const core = im.coreModel;
                            if (!core) return;

                            // allParametersRef から全パラメータを強制適用
                            const currentParams = allParametersRef.current;
                            if (currentParams.length > 0) {
                                if (core.setParameterValueById) {
                                    currentParams.forEach(p => core.setParameterValueById(p.id, p.value));
                                } else if (core.setParamFloat) {
                                    currentParams.forEach(p => core.setParamFloat(p.id, p.value));
                                }
                            }

                            // ポーズ更新（パーツ表示/非表示の管理のみ残す）
                            if (im.pose && im.pose.updateParameters) {
                                im.pose.updateParameters(core, dt);
                            }

                            // コアモデル更新（パラメータ値をドローアブルに反映）
                            if (core.update) core.update();
                        };
                    }

                    // パラメータ抽出
                    const core = model.internalModel.coreModel;
                    let extracted = [];
                    if (core) {
                        let ids = [], mins = [], maxs = [], defs = [];

                        // Cubism 4: coreModel は Framework の CubismModel ラッパー
                        // 生のコアモデル (Live2DCubismCore.Model) は _model にある
                        const rawCore = core._model || core;
                        if (rawCore && rawCore.parameters && rawCore.parameters.count > 0) {
                            const params = rawCore.parameters;
                            for (let i = 0; i < params.count; i++) {
                                ids.push(params.ids[i]);
                                mins.push(params.minimumValues[i]);
                                maxs.push(params.maximumValues[i]);
                                defs.push(params.defaultValues[i]);
                            }
                        } else if (core.getParamIds) { // Cubism 2
                             ids = core.getParamIds();
                             mins = core.getParamMinimumValues();
                             maxs = core.getParamMaximumValues();
                             defs = core.getParamDefaultValues();
                        }

                        if (ids && ids.length > 0) {
                            extracted = ids.map((id, i) => {
                                let val = defs[i];
                                try {
                                    if(core.getParameterValueById) val = core.getParameterValueById(id);
                                    else if(core.getParamFloat) val = core.getParamFloat(id);
                                } catch(e){}
                                if (val == null || isNaN(val)) val = defs[i] ?? 0;

                                // VTube Studioの設定があれば名前を上書き
                                let name = id;
                                if (vtubeSettings && vtubeSettings.ParameterSettings) {
                                    const match = vtubeSettings.ParameterSettings.find(s => s.OutputLive2D === id);
                                    if(match) name = match.Name;
                                }

                                return { id, min: mins[i], max: maxs[i], default: defs[i], value: val, name };
                            });
                        }
                    }
                    // 全パラメータ保持（Tickerで呼吸等も含め全て強制上書き）
                    setAllParameters(extracted);
                    // UIには顔関連パラメータのみ表示
                    setParameters(extracted.filter(p => isFaceParam(p.id)));
                    
                    // コンテナ配置
                    const container = new window.PIXI.Container();
                    container.addChild(model);
                    // screen はCSS論理ピクセル（ステージ座標系と一致）
                    const screenW = pixiAppRef.current.renderer.screen.width;
                    const screenH = pixiAppRef.current.renderer.screen.height;
                    const scale = (screenH * 0.5) / model.height;
                    container.scale.set(scale);
                    container.position.set(screenW / 2, screenH / 2);
                    
                    // ドラッグ設定
                    container.interactive = true;
                    container.buttonMode = true;
                    container.on('pointerdown', onDragStart);

                    // pointermove/pointerup はステージ全体で受け取る（高速ドラッグ対応）
                    const stage = pixiAppRef.current.stage;
                    stage.interactive = true;
                    stage.hitArea = new window.PIXI.Rectangle(0, 0, screenW, screenH);
                    stage.on('pointermove', onDragMove);
                    stage.on('pointerup', onDragEnd);
                    stage.on('pointerupoutside', onDragEnd);

                    stage.addChild(container);
                    modelRef.current = model;
                    modelContainerRef.current = container;
                    setModel(model);
                    
                    setTransform({ x: container.x, y: container.y, scale, rotation: 0 });

                    if (model.internalModel.settings.expressions) {
                        setExpressions(model.internalModel.settings.expressions.map(e => e.Name));
                    } else {
                        setExpressions([]);
                    }
                    
                    setLoading(false);

                } catch (e) {
                    console.error(e);
                    setErrorMsg('読み込みエラー: ' + e.message);
                    setLoading(false);
                }
            };

            const handleParamChange = (id, val) => {
                const v = parseFloat(val);
                setParameters(prev => prev.map(p => p.id === id ? { ...p, value: v } : p));
                setAllParameters(prev => prev.map(p => p.id === id ? { ...p, value: v } : p));

                // バッチ: 選択中の画像にも一括適用
                if (batchMode && selectedImageIdxs.size > 0) {
                    setBatchImages(prev => prev.map((img, i) => {
                        if (!selectedImageIdxs.has(i) && i !== currentImageIdx) return img;
                        return { ...img,
                            parameters: img.parameters.map(p => p.id === id ? { ...p, value: v } : p),
                            allParameters: img.allParameters.map(p => p.id === id ? { ...p, value: v } : p),
                        };
                    }));
                }
            };

            const handleParamReset = (id) => {
                setParameters(prev => prev.map(p => p.id === id ? { ...p, value: p.default } : p));
                setAllParameters(prev => prev.map(p => p.id === id ? { ...p, value: p.default } : p));
            };

            const handleAllParamsReset = () => {
                setParameters(prev => prev.map(p => ({ ...p, value: p.default })));
                setAllParameters(prev => prev.map(p => ({ ...p, value: p.default })));
            };

            // Dragging
            const dragData = useRef({ dragging: false, data: null, offset: {x:0, y:0} });
            const onDragStart = (e) => {
                const c = e.currentTarget;
                dragData.current.dragging = true;
                dragData.current.data = e.data;
                const pos = dragData.current.data.getLocalPosition(c.parent);
                dragData.current.offset.x = pos.x - c.x;
                dragData.current.offset.y = pos.y - c.y;
            };
            const onDragEnd = () => { dragData.current.dragging = false; dragData.current.data = null; };
            const onDragMove = () => {
                if(dragData.current.dragging && modelContainerRef.current) {
                    const c = modelContainerRef.current;
                    const pos = dragData.current.data.getLocalPosition(c.parent);
                    const nx = pos.x - dragData.current.offset.x;
                    const ny = pos.y - dragData.current.offset.y;
                    c.position.set(nx, ny);
                    setTransform(prev => ({...prev, x: nx, y: ny}));
                }
            };

            // Face Detection - 共通ロジック（1枚分）
            const calcFaceTransform = (landmarks, w, h) => {
                const forehead = landmarks[10], chin = landmarks[152];
                const lCheek = landmarks[454], rCheek = landmarks[234];
                const lEye = landmarks[33], rEye = landmarks[263];

                const foreheadX = forehead.x * w, foreheadY = forehead.y * h;
                const chinX = chin.x * w, chinY = chin.y * h;
                const faceW = Math.hypot((lCheek.x - rCheek.x)*w, (lCheek.y - rCheek.y)*h);
                const faceH = Math.hypot((forehead.x - chin.x)*w, (forehead.y - chin.y)*h);

                const headTopY = foreheadY - faceH * 0.3;
                const headH = chinY - headTopY;
                const headW = faceW * 1.4;
                const headCenterX = (foreheadX + chinX) / 2;
                const headCenterY = (headTopY + chinY) / 2;

                const dx = (rEye.x - lEye.x) * w;
                const dy = (rEye.y - lEye.y) * h;
                const angle = Math.atan2(dy, dx) * (180/Math.PI);

                const modelW = modelRef.current.internalModel.width;
                const modelH = modelRef.current.internalModel.height;
                const estimatedModelFaceW = modelW * 0.35;
                const scale = headW / estimatedModelFaceW;
                const modelFaceCenterLocalY = -modelH * 0.20;
                const angleRad = angle * Math.PI / 180;
                const offsetY = modelFaceCenterLocalY * scale;
                const cx = headCenterX + offsetY * Math.sin(angleRad);
                const cy = headCenterY - offsetY * Math.cos(angleRad);

                return { transform: { x: cx, y: cy, scale, rotation: angle }, headH, scale, modelFaceCenterLocalY };
            };

            // 1枚の画像に対してFaceMeshを実行
            const detectFaceInImage = (faceMesh, imageUrl, canvasSize) => {
                return new Promise((resolve) => {
                    faceMesh.onResults((results) => {
                        if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                            resolve(calcFaceTransform(results.multiFaceLandmarks[0], canvasSize.w, canvasSize.h));
                        } else {
                            resolve(null);
                        }
                    });
                    const img = new Image();
                    img.crossOrigin = "Anonymous";
                    img.onload = () => faceMesh.send({ image: img });
                    img.src = imageUrl;
                });
            };

            // 単体AI顔検出
            const detectFaceAndAlign = async () => {
                if(!bgImage || !modelRef.current) { alert('画像とモデルを読み込んでね！'); return; }
                if(!window.FaceMesh) { alert('顔検出ライブラリが読み込まれていません。'); return; }
                setLoading(true); setLoadingText('顔を探してるよ...');
                try {
                    const faceMesh = new window.FaceMesh({locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}`});
                    faceMesh.setOptions({maxNumFaces: 1, refineLandmarks: true});
                    const w = pixiAppRef.current.renderer.screen.width;
                    const h = pixiAppRef.current.renderer.screen.height;
                    const result = await detectFaceInImage(faceMesh, bgImage, { w, h });

                    if (result) {
                        setTransform(result.transform);

                        // マスク設定
                        let useSavedMask = false;
                        if (currentModelId) {
                            const m = savedModels.find(m => m.id === currentModelId);
                            if (m?.maskSettings?.enabled) {
                                setMaskSettings({ y: m.maskSettings.y, radius: m.maskSettings.radius });
                                setIsMasked(true);
                                useSavedMask = true;
                            }
                        }
                        if (!useSavedMask) {
                            setMaskSettings({ y: result.modelFaceCenterLocalY, radius: (result.headH / result.scale) * 0.55 });
                            setIsMasked(true);
                        }

                        // バッチモード時は現在の画像にも反映
                        if (batchMode && currentImageIdx >= 0) {
                            setBatchImages(prev => prev.map((img, i) =>
                                i === currentImageIdx ? { ...img, transform: result.transform, faceDetected: true } : img
                            ));
                        }
                        alert('顔発見！位置合わせたよ！');
                    } else {
                        alert('顔が見つからなかった...');
                    }
                    setLoading(false);
                } catch(e) {
                    console.error(e); alert('エラー: ' + e.message); setLoading(false);
                }
            };

            // 全画像一括AI顔検出
            const batchDetectFaces = async () => {
                if (!modelRef.current || batchImages.length === 0) return;
                if (!window.FaceMesh) { alert('顔検出ライブラリが読み込まれていません。'); return; }

                saveCurrentImageState();
                setLoading(true);

                const faceMesh = new window.FaceMesh({locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}`});
                faceMesh.setOptions({ maxNumFaces: 1, refineLandmarks: true });

                const updated = [...batchImages];
                let detected = 0;

                for (let i = 0; i < batchImages.length; i++) {
                    setLoadingText(`顔検出中... (${i + 1}/${batchImages.length})`);
                    const img = batchImages[i];
                    const result = await detectFaceInImage(faceMesh, img.url, img.canvasSize);
                    if (result) {
                        updated[i] = { ...updated[i], transform: result.transform, faceDetected: true };
                        detected++;
                    }
                    await new Promise(r => setTimeout(r, 50));
                }

                setBatchImages(updated);

                // 現在表示中の画像のtransformを更新
                const cur = updated[currentImageIdx];
                if (cur?.faceDetected) setTransform(cur.transform);

                // マスク設定（保存済みがあれば使う）
                if (currentModelId) {
                    const m = savedModels.find(m => m.id === currentModelId);
                    if (m?.maskSettings?.enabled) {
                        setMaskSettings({ y: m.maskSettings.y, radius: m.maskSettings.radius });
                        setIsMasked(true);
                    }
                }

                setLoading(false);
                alert(`顔検出完了！ ${detected}/${batchImages.length}枚で顔を検出しました。`);
            };

            const handleDownload = () => {
                if (!pixiAppRef.current) return;
                if (debugRingRef.current) debugRingRef.current.visible = false;
                pixiAppRef.current.renderer.render(pixiAppRef.current.stage);
                const a = document.createElement('a');
                a.download = 'vtuber_image.png';
                a.href = pixiAppRef.current.view.toDataURL('image/png');
                a.click();
                if (debugRingRef.current) debugRingRef.current.visible = true;
            };

            // 全画像一括ダウンロード
            const handleBatchDownload = async () => {
                if (!modelRef.current || batchImages.length === 0) return;
                saveCurrentImageState();
                setLoading(true);

                const app = pixiAppRef.current;
                const jsZip = new window.JSZip();
                if (debugRingRef.current) debugRingRef.current.visible = false;

                const savedImgs = [...batchImages];
                // 最新のstateを反映
                if (currentImageIdx >= 0) {
                    savedImgs[currentImageIdx] = { ...savedImgs[currentImageIdx], transform, allParameters, parameters, shuchuEnabled, shuchuSettings };
                }

                for (let i = 0; i < savedImgs.length; i++) {
                    setLoadingText(`画像を書き出し中... (${i + 1}/${savedImgs.length})`);
                    const img = savedImgs[i];

                    // 背景差し替え
                    if (bgSpriteRef.current) {
                        app.stage.removeChild(bgSpriteRef.current);
                        bgSpriteRef.current.destroy({ texture: true, baseTexture: true });
                    }
                    app.renderer.resize(img.canvasSize.w, img.canvasSize.h);
                    const bg = window.PIXI.Sprite.from(img.url);
                    bg.width = img.canvasSize.w; bg.height = img.canvasSize.h;
                    bg.zIndex = -1;
                    app.stage.addChildAt(bg, 0);
                    bgSpriteRef.current = bg;

                    // transform適用
                    if (modelContainerRef.current) {
                        const c = modelContainerRef.current;
                        c.position.set(img.transform.x, img.transform.y);
                        c.scale.set(img.transform.scale);
                        c.rotation = img.transform.rotation * (Math.PI / 180);
                    }
                    // パラメータ適用
                    allParametersRef.current = img.allParameters;

                    // 集中線の適用（画像ごと）
                    if (shuchuSpriteRef.current) {
                        if (img.shuchuEnabled) {
                            shuchuSpriteRef.current.visible = true;
                            shuchuSpriteRef.current.position.set(img.shuchuSettings.x, img.shuchuSettings.y);
                            shuchuSpriteRef.current.scale.set(img.shuchuSettings.scaleX, img.shuchuSettings.scaleY);
                            shuchuSpriteRef.current.alpha = img.shuchuSettings.opacity;
                        } else {
                            shuchuSpriteRef.current.visible = false;
                        }
                    }

                    await new Promise(r => setTimeout(r, 100));
                    app.renderer.render(app.stage);
                    const dataUrl = app.view.toDataURL('image/png');
                    const base64Data = dataUrl.split(',')[1];
                    const padIdx = String(i + 1).padStart(3, '0');
                    const baseName = img.name.replace(/\.[^.]+$/, '');
                    jsZip.file(`${padIdx}_${baseName}.png`, base64Data, { base64: true });
                }

                // 元の画像に戻す
                switchToImage(currentImageIdx, savedImgs);
                if (debugRingRef.current) debugRingRef.current.visible = true;

                setLoadingText('ZIPを生成中...');
                const blob = await jsZip.generateAsync({ type: 'blob' });
                const a = document.createElement('a');
                a.download = `vtuber_batch_${Date.now()}.zip`;
                a.href = URL.createObjectURL(blob);
                a.click();
                URL.revokeObjectURL(a.href);
                setLoading(false);
            };

            if (!libsLoaded) {
                return (
                    <div className="flex flex-col h-screen items-center justify-center text-gray-600 space-y-4">
                        <div className="w-16 h-16 border-4 border-indigo-200 border-t-indigo-600 rounded-full animate-spin"></div>
                        <p className="font-bold">準備中... {loadProgress}%</p>
                    </div>
                );
            }

            return (
                <div className="flex h-screen overflow-hidden">
                    {/* Sidebar */}
                    <div className="w-72 bg-white shadow-xl flex flex-col z-10 border-r border-gray-200">
                        <div className="px-4 py-3 border-b border-gray-100 bg-white sticky top-0 z-20">
                            <h1 className="text-base font-bold text-indigo-600 flex items-center gap-2">
                                <Icons.Layers className="w-5 h-5"/> 2.5D VTuber Maker
                            </h1>
                        </div>

                        <div className="flex-1 overflow-y-auto px-3 py-3 space-y-3">
                            {/* Uploads */}
                            <div className="grid grid-cols-2 gap-2">
                                <label className="flex flex-col items-center justify-center h-16 border-2 border-dashed border-gray-300 rounded-lg cursor-pointer hover:bg-indigo-50 transition-all">
                                    <Icons.ImageIcon className="w-4 h-4 text-gray-400 mb-0.5"/>
                                    <span className="text-[10px] text-gray-500 font-bold">1. 写真</span>
                                    <input type="file" accept="image/*" onChange={handleImageUpload} className="hidden" />
                                </label>
                                <label className="flex flex-col items-center justify-center h-16 border-2 border-dashed border-gray-300 rounded-lg cursor-pointer hover:bg-indigo-50 transition-all">
                                    <Icons.Upload className="w-4 h-4 text-gray-400 mb-0.5"/>
                                    <span className="text-[10px] text-gray-500 font-bold">2. モデル(ZIP)</span>
                                    <input type="file" accept=".zip" onChange={handleZipUpload} className="hidden" />
                                </label>
                            </div>

                            {/* Saved Models - 常に表示 */}
                            <div className="space-y-1.5 p-2 bg-gray-50 rounded-lg">
                                <h3 className="text-[10px] font-bold text-gray-500 flex items-center gap-1"><Icons.Database className="w-3 h-3"/> 保存済みモデル</h3>
                                {savedModels.length > 0 ? (
                                    <div className="space-y-1 max-h-40 overflow-y-auto">
                                        {savedModels.map(m => (
                                            <div key={m.id} className={`flex items-center gap-1 group ${currentModelId === m.id ? 'ring-2 ring-indigo-400 rounded-lg' : ''}`}>
                                                <button onClick={() => loadModelFromFirebase(m.id)} disabled={loading}
                                                    className="flex-1 text-left text-[10px] font-bold bg-white hover:bg-indigo-50 px-2 py-1.5 rounded-lg transition-colors truncate flex items-center gap-1.5 disabled:opacity-50 shadow-sm">
                                                    <Icons.FolderOpen className="w-3 h-3 text-indigo-400 shrink-0"/>
                                                    <span className="truncate">{m.name}</span>
                                                    <span className="text-[8px] text-gray-300 shrink-0">{m.size ? (m.size/1024/1024).toFixed(1)+'MB' : ''}</span>
                                                </button>
                                                <button onClick={() => deleteModelFromFirebase(m.id)} title="削除"
                                                    className="text-gray-300 hover:text-red-500 shrink-0 opacity-0 group-hover:opacity-100 transition-all">
                                                    <Icons.Trash2 className="w-3 h-3"/>
                                                </button>
                                            </div>
                                        ))}
                                    </div>
                                ) : (
                                    <p className="text-[10px] text-gray-400 text-center py-1">
                                        {authReady ? 'モデルを保存するとここに表示されます' : '認証中...'}
                                    </p>
                                )}
                            </div>

                            {/* 表情プリセット - 現在のモデル用 */}
                            <div className="space-y-1.5 p-2 bg-pink-50 rounded-lg">
                                <h3 className="text-[10px] font-bold text-pink-500 flex items-center gap-1">
                                    <Icons.Star className="w-3 h-3"/> 表情プリセット
                                    {currentModelId && savedModels.length > 0 && (
                                        <span className="text-[8px] text-pink-400 ml-1">- {savedModels.find(m => m.id === currentModelId)?.name || ''}</span>
                                    )}
                                </h3>
                                {currentModelId && savedPresets.length > 0 ? (
                                    <div className="space-y-1 max-h-32 overflow-y-auto">
                                        {savedPresets.map(pr => (
                                            <div key={pr.id} className="flex items-center gap-1 group">
                                                <button onClick={() => applyPreset(pr)}
                                                    className="flex-1 text-left text-[10px] font-bold text-pink-600 hover:text-pink-800 bg-white hover:bg-pink-100 px-2 py-1 rounded shadow-sm transition-colors truncate">
                                                    {pr.name}
                                                </button>
                                                <button onClick={() => deletePreset(pr.id)} title="削除"
                                                    className="text-gray-300 hover:text-red-500 shrink-0 opacity-0 group-hover:opacity-100 transition-all">
                                                    <Icons.Trash2 className="w-3 h-3"/>
                                                </button>
                                            </div>
                                        ))}
                                    </div>
                                ) : (
                                    <p className="text-[10px] text-gray-400 text-center py-1">
                                        {currentModelId ? '表情を保存するとここに表示されます' : 'モデルを選択/保存してから表情を保存できます'}
                                    </p>
                                )}
                            </div>

                            {errorMsg && <div className="p-2 bg-red-50 text-red-600 text-[10px] rounded-lg flex gap-1"><Icons.AlertCircle className="w-3 h-3 shrink-0 mt-0.5"/>{errorMsg}</div>}

                            {/* Auto Align */}
                            <div className="space-y-1.5">
                                <button onClick={detectFaceAndAlign} disabled={!bgImage || !model || loading}
                                    className={`w-full py-2 rounded-lg flex items-center justify-center gap-2 font-bold text-xs shadow-sm transition-all ${!bgImage || !model ? 'bg-gray-100 text-gray-400' : 'bg-gradient-to-r from-indigo-500 to-purple-600 text-white hover:shadow-md'}`}>
                                    <Icons.RefreshCw className={`w-3 h-3 ${loading ? 'animate-spin' : ''}`}/>
                                    AI 顔検出{batchMode ? ' (現在の画像)' : '＆自動配置'}
                                </button>
                                {batchMode && (
                                    <button onClick={batchDetectFaces} disabled={!model || loading || batchImages.length === 0}
                                        className="w-full py-2 rounded-lg flex items-center justify-center gap-2 font-bold text-xs shadow-sm transition-all bg-gradient-to-r from-purple-500 to-pink-600 text-white hover:shadow-md disabled:opacity-50">
                                        <Icons.Target className="w-3 h-3"/>
                                        全画像AI検出 ({batchImages.length}枚)
                                    </button>
                                )}
                                {batchMode && selectedImageIdxs.size > 0 && (
                                    <p className="text-[9px] text-pink-500 font-bold text-center">
                                        {selectedImageIdxs.size}枚選択中 - 表情変更は一括適用されます
                                    </p>
                                )}
                            </div>

                            {/* Controls */}
                            {model && (
                                <div className="space-y-3">
                                    {/* Transform */}
                                    <div className="space-y-1.5">
                                        <h3 className="text-[10px] font-bold text-gray-500 flex items-center gap-1"><Icons.Move className="w-3 h-3"/> 位置・サイズ</h3>
                                        <div className="space-y-1">
                                            <div className="flex items-center gap-2">
                                                <label className="text-[10px] text-gray-400 w-8 shrink-0">サイズ</label>
                                                <input type="range" min="0" max="0.40" step="0.002" value={transform.scale} onChange={(e)=>setTransform({...transform, scale: Number(e.target.value)})} className="range-slider flex-1"/>
                                                <span className="text-[10px] text-gray-400 w-8 text-right">{transform.scale.toFixed(2)}</span>
                                            </div>
                                            <div className="flex items-center gap-2">
                                                <label className="text-[10px] text-gray-400 w-8 shrink-0">回転</label>
                                                <input type="range" min="-180" max="180" step="1" value={transform.rotation} onChange={(e)=>setTransform({...transform, rotation: Number(e.target.value)})} className="range-slider flex-1"/>
                                                <span className="text-[10px] text-gray-400 w-8 text-right">{transform.rotation}°</span>
                                            </div>
                                        </div>
                                    </div>

                                    {/* Mask */}
                                    <div className="p-2 bg-indigo-50 rounded-lg space-y-1.5">
                                        <div className="flex justify-between items-center">
                                            <label className="text-[10px] font-bold text-indigo-700 flex gap-1"><Icons.Scissors className="w-3 h-3"/> 円形切り抜き</label>
                                            <input type="checkbox" checked={isMasked} onChange={(e)=>setIsMasked(e.target.checked)} className="accent-indigo-600 w-3.5 h-3.5"/>
                                        </div>
                                        {isMasked && (
                                            <div className="space-y-1">
                                                <div className="flex items-center gap-2"><label className="text-[10px] text-indigo-400 w-6 shrink-0">範囲</label><input type="range" min="50" max="1000" value={maskSettings.radius} onChange={(e)=>setMaskSettings({...maskSettings, radius: Number(e.target.value)})} className="range-slider flex-1"/></div>
                                                <div className="flex items-center gap-2"><label className="text-[10px] text-indigo-400 w-6 shrink-0">Y</label><input type="range" min="-1000" max="1000" value={maskSettings.y} onChange={(e)=>setMaskSettings({...maskSettings, y: Number(e.target.value)})} className="range-slider flex-1"/></div>
                                            </div>
                                        )}
                                    </div>

                                    {/* 集中線フィルター */}
                                    <div className="p-2 bg-amber-50 rounded-lg space-y-1.5">
                                        <div className="flex justify-between items-center">
                                            <label className="text-[10px] font-bold text-amber-700 flex gap-1"><Icons.Target className="w-3 h-3"/> 集中線</label>
                                            <input type="checkbox" checked={shuchuEnabled} onChange={(e)=>setShuchuEnabled(e.target.checked)} className="accent-amber-600 w-3.5 h-3.5"/>
                                        </div>
                                        {shuchuEnabled && (
                                            <div className="space-y-1">
                                                <div className="flex items-center gap-2">
                                                    <label className="text-[10px] text-amber-500 w-6 shrink-0">幅</label>
                                                    <input type="range" min="0.1" max="5.0" step="0.05" value={shuchuSettings.scaleX}
                                                        onChange={(e)=>setShuchuSettings(p=>({...p, scaleX: Number(e.target.value)}))} className="range-slider flex-1"/>
                                                    <span className="text-[9px] text-gray-400 w-7 text-right">{shuchuSettings.scaleX.toFixed(1)}</span>
                                                </div>
                                                <div className="flex items-center gap-2">
                                                    <label className="text-[10px] text-amber-500 w-6 shrink-0">高さ</label>
                                                    <input type="range" min="0.1" max="5.0" step="0.05" value={shuchuSettings.scaleY}
                                                        onChange={(e)=>setShuchuSettings(p=>({...p, scaleY: Number(e.target.value)}))} className="range-slider flex-1"/>
                                                    <span className="text-[9px] text-gray-400 w-7 text-right">{shuchuSettings.scaleY.toFixed(1)}</span>
                                                </div>
                                                <div className="flex items-center gap-2">
                                                    <label className="text-[10px] text-amber-500 w-6 shrink-0">透明</label>
                                                    <input type="range" min="0" max="1.0" step="0.05" value={shuchuSettings.opacity}
                                                        onChange={(e)=>setShuchuSettings(p=>({...p, opacity: Number(e.target.value)}))} className="range-slider flex-1"/>
                                                    <span className="text-[9px] text-gray-400 w-7 text-right">{(shuchuSettings.opacity * 100).toFixed(0)}%</span>
                                                </div>
                                                <p className="text-[8px] text-amber-400 text-center">ドラッグで移動できます</p>
                                            </div>
                                        )}
                                    </div>

                                    {/* Parameters - カテゴリ別折りたたみ */}
                                    <div className="space-y-1">
                                        <div className="flex justify-between items-center">
                                            <h3 className="text-[10px] font-bold text-gray-500 flex items-center gap-1"><Icons.Sliders className="w-3 h-3"/> パラメータ調整</h3>
                                            <button onClick={handleAllParamsReset} className="text-[9px] text-indigo-500 hover:text-indigo-700 font-bold px-1.5 py-0.5 rounded hover:bg-indigo-50 transition-colors">全リセット</button>
                                        </div>
                                        <div className="space-y-1 max-h-[calc(100vh-480px)] overflow-y-auto pr-1">
                                            {FACE_CATEGORIES.map(cat => {
                                                const catParams = parameters.filter(p => getFaceCategory(p.id) === cat.key);
                                                if (catParams.length === 0) return null;
                                                const isOpen = openCategories[cat.key];
                                                return (
                                                    <div key={cat.key} className="border border-gray-100 rounded-lg overflow-hidden">
                                                        <button onClick={() => toggleCategory(cat.key)}
                                                            className="w-full flex justify-between items-center px-2 py-1.5 bg-gray-50 hover:bg-gray-100 transition-colors text-left">
                                                            <span className="text-[10px] font-bold text-gray-600">{cat.label} ({catParams.length})</span>
                                                            <span className="text-[10px] text-gray-400">{isOpen ? '−' : '+'}</span>
                                                        </button>
                                                        {isOpen && (
                                                            <div className="px-2 py-1.5 space-y-1.5">
                                                                {catParams.map(p => (
                                                                    <div key={p.id} className="flex items-center gap-1">
                                                                        <span className="text-[9px] font-bold text-gray-600 truncate w-16 shrink-0" title={p.id}>{p.name.replace(/^Param/, '')}</span>
                                                                        <input type="range"
                                                                            min={p.min} max={p.max} step={(p.max-p.min)/100 || 0.01}
                                                                            value={p.value}
                                                                            onChange={(e)=>handleParamChange(p.id, e.target.value)}
                                                                            className="range-slider flex-1 accent-pink-500"/>
                                                                        <span className="text-[9px] text-gray-400 w-7 text-right shrink-0">{p.value.toFixed(1)}</span>
                                                                        <button onClick={()=>handleParamReset(p.id)} title="デフォルトに戻す"
                                                                            className="text-[9px] text-gray-300 hover:text-indigo-500 shrink-0 w-3.5 h-3.5 flex items-center justify-center transition-colors">
                                                                            <Icons.RefreshCw className="w-2.5 h-2.5"/>
                                                                        </button>
                                                                    </div>
                                                                ))}
                                                            </div>
                                                        )}
                                                    </div>
                                                );
                                            })}
                                            {parameters.length === 0 && <p className="text-[10px] text-gray-400 text-center py-2">パラメータなし</p>}
                                        </div>
                                    </div>
                                </div>
                            )}

                            {/* Save Model & Preset */}
                            {model && (
                                <div className="grid grid-cols-2 gap-1.5">
                                    <button onClick={saveModelToFirebase} disabled={!currentZipFile || loading}
                                        className="py-1.5 bg-amber-500 hover:bg-amber-600 text-white rounded-lg font-bold text-[10px] shadow-sm transition-all flex items-center justify-center gap-1 disabled:opacity-50">
                                        <Icons.Save className="w-3 h-3"/> モデル保存
                                    </button>
                                    <button onClick={savePreset} disabled={!currentModelId || parameters.length === 0}
                                        className="py-1.5 bg-pink-500 hover:bg-pink-600 text-white rounded-lg font-bold text-[10px] shadow-sm transition-all flex items-center justify-center gap-1 disabled:opacity-50">
                                        <Icons.Star className="w-3 h-3"/> 表情保存
                                    </button>
                                </div>
                            )}

                            {batchMode ? (
                                <div className="grid grid-cols-2 gap-1.5">
                                    <button onClick={handleDownload} disabled={!model || !bgImage}
                                        className="py-2 bg-green-500 hover:bg-green-600 text-white rounded-lg font-bold text-[10px] shadow-md transition-all flex items-center justify-center gap-1 disabled:opacity-50">
                                        <Icons.Download className="w-3 h-3"/> 現在の画像
                                    </button>
                                    <button onClick={handleBatchDownload} disabled={!model || batchImages.length === 0 || loading}
                                        className="py-2 bg-emerald-600 hover:bg-emerald-700 text-white rounded-lg font-bold text-[10px] shadow-md transition-all flex items-center justify-center gap-1 disabled:opacity-50">
                                        <Icons.Download className="w-3 h-3"/> 全画像ZIP
                                    </button>
                                </div>
                            ) : (
                                <button onClick={handleDownload} disabled={!model} className="w-full py-2 bg-green-500 hover:bg-green-600 text-white rounded-lg font-bold text-xs shadow-md transition-all flex items-center justify-center gap-2 disabled:opacity-50">
                                    <Icons.Download className="w-4 h-4"/> 画像保存
                                </button>
                            )}
                        </div>
                    </div>

                    {/* Canvas Area */}
                    <div className="flex-1 flex flex-col bg-gray-200 overflow-hidden"
                        onDragEnter={handleDragEnter} onDragLeave={handleDragLeave} onDragOver={handleDragOver} onDrop={handleDrop}>

                        {/* Canvas */}
                        <div className="flex-1 flex items-center justify-center p-4 relative overflow-hidden">
                            <div ref={canvasRef} className="shadow-2xl bg-white border-4 border-white rounded-sm relative z-0"></div>

                            {/* Loading Overlay */}
                            {loading && (
                                <div className="absolute inset-0 bg-black/50 backdrop-blur-sm z-50 flex flex-col items-center justify-center text-white">
                                    <div className="w-12 h-12 border-4 border-white border-t-transparent rounded-full animate-spin mb-4"></div>
                                    <p className="font-bold">{loadingText}</p>
                                </div>
                            )}

                            {/* Empty State */}
                            {!bgImage && !loading && !isDragging && (
                                <div className="absolute pointer-events-none text-gray-400 flex flex-col items-center">
                                    <Icons.ImageIcon className="w-16 h-16 opacity-20 mb-2"/>
                                    <p>写真をアップロードしてね！</p>
                                    <p className="text-xs mt-1 opacity-60">ドラッグ&ドロップもOK</p>
                                </div>
                            )}

                            {/* Drag Overlay */}
                            {isDragging && (
                                <div className="absolute inset-0 bg-indigo-500/20 backdrop-blur-sm z-50 flex flex-col items-center justify-center border-4 border-dashed border-indigo-400 rounded-lg pointer-events-none">
                                    <Icons.Upload className="w-16 h-16 text-indigo-500 mb-3 animate-bounce"/>
                                    <p className="text-indigo-700 font-bold text-lg">ここにドロップ！</p>
                                    <p className="text-indigo-500 text-sm mt-1">画像 or モデル(ZIP)</p>
                                </div>
                            )}
                        </div>

                        {/* Batch Preview Panel */}
                        {batchMode && batchImages.length > 0 && (
                            <div className="bg-white border-t border-gray-300 px-3 py-2 flex items-center gap-2 shrink-0" style={{height: '110px'}}>
                                {/* 選択コントロール */}
                                <div className="flex flex-col gap-0.5 shrink-0 items-center">
                                    <button onClick={selectAllImages} className="text-[9px] text-indigo-500 hover:text-indigo-700 font-bold">全選択</button>
                                    <button onClick={deselectAllImages} className="text-[9px] text-gray-400 hover:text-gray-600 font-bold">解除</button>
                                    <span className="text-[9px] text-gray-400 mt-0.5">{selectedImageIdxs.size}/{batchImages.length}</span>
                                </div>

                                {/* ページナビ */}
                                <button onClick={() => { saveCurrentImageState(); switchToImage(Math.max(0, currentImageIdx - 1)); }}
                                    disabled={currentImageIdx <= 0} className="text-gray-400 hover:text-indigo-500 disabled:opacity-30 shrink-0 text-lg font-bold">&#9664;</button>

                                {/* サムネイル */}
                                <div className="flex gap-1.5 overflow-x-auto flex-1 py-1">
                                    {batchImages.map((img, i) => {
                                        const isCurrent = i === currentImageIdx;
                                        const isSelected = selectedImageIdxs.has(i);
                                        return (
                                            <div key={i} className="relative shrink-0 cursor-pointer group"
                                                onClick={() => { saveCurrentImageState(); switchToImage(i); }}>
                                                <img src={img.thumbnailUrl} alt={img.name}
                                                    className={`h-16 w-auto rounded border-2 transition-all ${
                                                        isCurrent ? 'border-indigo-500 shadow-lg' :
                                                        isSelected ? 'border-pink-400' : 'border-gray-200 hover:border-gray-400'
                                                    }`} />
                                                <div className="absolute top-0.5 left-0.5" onClick={(e) => e.stopPropagation()}>
                                                    <input type="checkbox" checked={isSelected}
                                                        onChange={() => toggleImageSelection(i)}
                                                        className="accent-pink-500 w-3 h-3 cursor-pointer" />
                                                </div>
                                                <div className="absolute top-0.5 right-0.5" onClick={(e) => { e.stopPropagation();
                                                    if (isCurrent) {
                                                        setShuchuEnabled(prev => !prev);
                                                    }
                                                    setBatchImages(prev => prev.map((im, j) => j === i ? { ...im, shuchuEnabled: !im.shuchuEnabled } : im));
                                                }}>
                                                    <div className={`w-3.5 h-3.5 rounded-full flex items-center justify-center text-[7px] font-bold cursor-pointer transition-colors ${
                                                        (isCurrent ? shuchuEnabled : img.shuchuEnabled) ? 'bg-amber-500 text-white' : 'bg-gray-300/70 text-gray-500'
                                                    }`} title="集中線">集</div>
                                                </div>
                                                <div className="absolute bottom-0 left-0 right-0 bg-black/50 text-white text-[8px] text-center py-0.5 rounded-b">
                                                    {i + 1}{img.faceDetected ? ' \u2713' : ''}
                                                </div>
                                            </div>
                                        );
                                    })}
                                </div>

                                {/* ページナビ */}
                                <button onClick={() => { saveCurrentImageState(); switchToImage(Math.min(batchImages.length - 1, currentImageIdx + 1)); }}
                                    disabled={currentImageIdx >= batchImages.length - 1} className="text-gray-400 hover:text-indigo-500 disabled:opacity-30 shrink-0 text-lg font-bold">&#9654;</button>

                                <span className="text-[9px] text-gray-400 shrink-0">{currentImageIdx + 1}/{batchImages.length}</span>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
